# 排序算法总结

| 算法     | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 稳定性 |
| :------- | :------------- | -------- | -------- | ---------- | ------ |
| 冒泡排序 | O(n^2)         | O(n)     | O(n^2)   | O(1)       | 稳定   |
| 选择排序 | O(n^2)         | O(n^2)   | O(n^2)   | O(1)       | 不稳定 |
| 插入排序 | O(n^2)         | O(n)     | O(n^2)   | O(1)       | 稳定   |
| 希尔排序 | O(nlogn)       | O(n^1.3) | O(n^2)   | O(1)       | 不稳定 |
| 归并排序 | O(nlogn)       | O(nlogn) | O(nlogn) | O(n)       | 稳定   |
| 快速排序 | O(nlogn)       | O(nlogn) | O(n^2)   | O(logn)    | 不稳定 |
| 堆排序   | O(nlogn)       | O(nlogn) | O(nlogn) | O(1)       | 不稳定 |
| 桶排序   | O(n+k)         | O(n+k)   | O(n^2)   | O(n+k)     | 稳定   |
| 计数排序 | O(n+k)         | O(n+k)   | O(n+k)   | O(k)       | 稳定   |
| 基数排序 | O(n×m)         | O(n×m)   | O(n×m)   | O(n+m)     | 稳定   |

## 冒泡排序

![img](排序总结.assets/849589-20171015223238449-2146169197.gif)

```cpp
void bubbleSort(vector<int>&q) {
    for(int i = q.size()-1;i>0;i--) {
        bool flag = false;
        for(int j = 0;j<i;++j) {
            if(q[j]>q[j+1]) {
                swap(q[j],q[j+1]);
                flag = true;
            }
        }
    if(!flag) break;//当flag == false 说明未进行交换，排序结束
    }
}
```

## 选择排序

![img](排序总结.assets/849589-20171015224719590-1433219824.gif)

~~~cpp
void selectSort(vector<int>&q) {
    for(int i = 0;i<q.size();++i) {
        for(int j = i+1;j<q.size();++j) {
			if(q[i]>q[j]) 
                swap(q[i],q[j]);//每次交换都会改变原来的顺序，所以不稳定
        }
    }
}
~~~

## 插入排序

![img](排序总结.assets/849589-20171015225645277-1151100000.gif)

~~~cpp
void insertSort(vector<int>&q) {
    for(int i = 1;i<q.size();++i) {
        int tmp = q[i];//暂存最后一个数字，防止后移数组时被覆盖
        for(int j = i-1;j>=0;--j) {
			if(q[j]>tmp) {//如果每个数字都在正确的位置就只有一层for，此时最优时间复杂度O(n)
                q[j+1] = q[j];//后移
            }
            else break;
        }
        q[j+1] = tmp;//q[j]>tmp,找到位置
    }
}
~~~

## 希尔排序

![img](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiadtZekLQySMDdNsZTx6jyaO6spIkjPFjwqfdhd2XfRUnic1PjV1yRxrw/640?wx_fmt=gif)



~~~cpp
//shell发明的，是对插排的优化
//先整体排序，此时数字少，排序快
//再细化排序，此时对然数字多，但是已经大致有序，故排序也较快
void shellSort(vector<int>&q) {
    int gap = q.size()/2;//只有一个数字不需要排序
    while(gap) {
		for(int i = gap;i<q.size();i+=gap) {
			int t = q[i];
            for(int j = i-gap;j>=0;j -= gap) {
				if(q[j]>t)
                    q[j+gap] = q[j];
                else break;
            }
            q[j+gap] = t;
        }
        gap /= 2;
    }
}
~~~

## 归并排序

![img](排序总结.assets/849589-20171015230557043-37375010.gif)



~~~cpp
vector<int>tmp;
void mergeSort(vector<int>&q, int l, int r) {
	if(l>=r) return;//结束条件
	int mid = l+r >>1;
	mergeSort(q,l,mid),mergeSort(q,mid+1,r);//拆分
	int i = l, j = mid+1;
	while (i <= mid && j <= r) {//合并
		if(q[i]>q[j]) 
            tmp.push_back(q[j++]);
		else 
            tmp.push_back(q[i++]);
	}
	while(i<=mid)tmp.push_back(q[i++]);//处理剩余的元素
	while(j<=r)tmp.push_back(q[j++]);
	for(int i : tmp) q[l++]=tmp[j];	//放回原数组
}
~~~

## 快速排序

![img](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaAY3VU8iaziaYcxAasTdrIu69BOVPYtfvqdvicmlJDS94cG2tjwZhVkdHA/640?wx_fmt=gif)



~~~cpp
void quick_sort(vector<int>&q,int l, int r) {
	if(l>=r) return;//结束条件
	int x = q[l], i = l - 1, j = r + 1;
	while (i<j)
	{
		do i++; while (q[i]<x);
		do j--; while (q[j]>x);
		if(i<j) swap(q[i],q[j]);
	}
    //如果用i作为分界值，一定要用j作为分界点，防止边界问题
	quick_sort(1,l,j);
	quick_sort(1,j+1,r);
}
~~~

## 堆排序

![img](排序总结.assets/640-163845224313912.gif)

~~~cpp
//一般用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)/2；其左右子结点分别为 (2i + 1)、(2i + 2)
//步骤：创建最大堆，调整最大堆
void max_heapify(vector<int>q,int start,int end) {
	int dad = start;
    int son = dad*2+1;
    while(son<=end) {
		if(son+1<=end&&q[son]<q[son+1])//左右子节点哪个大就和父节点交换
            son++;
        if(q[dad]>q[son]) return;
        else {
			swap(q[dad],q[son]);
            //继续和孙节点比较
            dad = son;
            son = dad * 2 + 1;
        }
    }
}

void heapSort(vector<int>q,int len) {
    //大根堆的构建
	for(int i = len/2-1;i>=0;--i) //从最后一个父节点开始
        max_heapify(q,i,len-1);
    
    //大根堆的维护
    for(int i = len-1;i>0;--i) {
        //把大的数字放在数组后面不再参与维护
		swap(q[0],q[i]);
        max_heapify(q,0,i-1);
    }
}
~~~

## 桶排序

![img](排序总结.assets/640-163845391932015.gif)

~~~cpp
//把区间 [minV, maxV] 均匀划分成 k 个区间，每个区间就是一个桶。
const int BUCKET_NUM = 10;

struct ListNode{
        explicit ListNode(int i=0):mData(i),mNext(NULL){}
        ListNode* mNext;
        int mData;
};

ListNode* insert(ListNode* head,int val){
        ListNode dummyNode;
        ListNode *newNode = new ListNode(val);
        ListNode *pre,*curr;
        dummyNode.mNext = head;
        pre = &dummyNode;
        curr = head;
        while(NULL!=curr && curr->mData<=val){
                pre = curr;
                curr = curr->mNext;
        }
        newNode->mNext = curr;
        pre->mNext = newNode;
        return dummyNode.mNext;
}


ListNode* Merge(ListNode *head1,ListNode *head2){
        ListNode dummyNode;
        ListNode *dummy = &dummyNode;
        while(NULL!=head1 && NULL!=head2){
                if(head1->mData <= head2->mData){
                        dummy->mNext = head1;
                        head1 = head1->mNext;
                }else{
                        dummy->mNext = head2;
                        head2 = head2->mNext;
                }
                dummy = dummy->mNext;
        }
        if(NULL!=head1) dummy->mNext = head1;
        if(NULL!=head2) dummy->mNext = head2;
       
        return dummyNode.mNext;
}

void BucketSort(int n,int arr[]){
        vector<ListNode*> buckets(BUCKET_NUM,(ListNode*)(0));
        for(int i=0;i<n;++i){
                int index = arr[i]/BUCKET_NUM;
                ListNode *head = buckets.at(index);
                buckets.at(index) = insert(head,arr[i]);
        }
        ListNode *head = buckets.at(0);
        for(int i=1;i<BUCKET_NUM;++i){
                head = Merge(head,buckets.at(i));
        }
        for(int i=0;i<n;++i){
                arr[i] = head->mData;
                head = head->mNext;
        }
}
~~~



## 计数排序

![img](排序总结.assets/849589-20171015231740840-6968181.gif)

~~~cpp
//开一个长度为 maxValue-minValue+1 的数组
void countSort(vector<int>&q,int n) {//最大值记录为n
	vector<int>countArr(n+1,0);
    for(int i = 0;i<q.size();+=i) {
        countArr[q[i]]++;//记录每个数字的个数，不记录个数可用于去重排序
        
        for(int i = 0;i<countArr.size();++i) {
            while(countArr[i]>0) {
                arr.push_back(countArr[i]);
                countArr[i]--;
            }
        }
    }
}
~~~

## 基数排序

![img](排序总结.assets/640-163845392788017.gif)

~~~cpp
//从最低位开始，依次进行一次稳定排序。
int maxbit(int data[], int n) //辅助函数，求数据的最大位数
{
    int maxData = data[0];              ///< 最大数
    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。
    for (int i = 1; i < n; ++i)
    {
        if (maxData < data[i])
            maxData = data[i];
    }
    int d = 1;
    int p = 10;
    while (maxData >= p)
    {
        maxData /= 10;
        ++d;
    }
    return d;
}
void radixsort(int data[], int n) //基数排序
{
    int d = maxbit(data, n);
    int *tmp = new int[n];
    int *count = new int[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i <= d; i++) //进行d次排序
    {
        for(j = 0; j < 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j < n; j++)
        {
            k = (data[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j < 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for(j = 0; j < n; j++) //将临时数组的内容复制到data中
            data[j] = tmp[j];
        radix = radix * 10;
    }
    delete []tmp;
    delete []count;
}
~~~

