# 快速幂(二分思想)

## 求x的n次方

~~~cpp
/////////////////////////////////////////////////////////////////////
int func1(int x,int n)
{
    int ans = 1;
    for(int i = 0;i<n;++i)//循环的时间复杂度O(n)
        ans *= x;
    return ans;
}
/////////////////////////////////////////////////////////////////////
int func2(int x,int n)
{
	if(n == 0)return 1;
    return func2(x,n-1)*x;//同上
}
/////////////////////////////////////////////////////////////////////
int func3(int x,int n)
{
    if(n == 0)return 1;
    if(n%2 == 1) return func3(x,n/2)*func(x,n/2)*x;//左右都递归调用
    return func3(x,n/2)*func3(x,n/2);
}
//						      17							2^0	
//							 /	\							 +
//							8	 8  //*x是O(1)忽略			  2^1
//						   / \	...							 +
//						  4   4	  ...						2^2
//                      /  \	    ...						 +
//                     2    2		  ...   				2^3
//					等比数列求和， 仍是O(n)
/////////////////////////////////////////////////////////////////////
int func4(int x,int n)
{
	if(n == 0)return 1;
    int t = func4(x,n/2);//仅一次递归调用，然后把值存下
    if(n%2 == 1)
        return t*t*x;
    return t*t;
}//O(logn)
/////////////////////////////////////////////////////////////////////
~~~

# 遇到相同的递归操作，可以将这个值存下，可以减少递归操作量。

## 斐波那契数列

~~~cpp
//递归不剪枝	时间复杂度O(2^n)
int fib(int n)
{
	if(n <= 0) return 0;
    if(n < 3) return 1;
    return fib(n-1)+fib(n-2);
}

//递归剪枝	O(n)
int fib(int first,int second,int n)
{
	if(n <= 0) return 0;
    if(n < 3) return 1;
    else if(n == 3) return first + second;
    return fib(second,first+second,n-1);
}

//非递归	O(n)
int fib(int n)
{
    if(n < 1) return 0;
    else if(n == 1 || n == 2) return 1;
    int res = 1;
    int pre = 1;
    int temp = 0;
    for(int i = 3; i < n; i++) {
        temp = res;
        res = pre + res;
        pre  = temp;
    }
    return res;
}
~~~

# 多指针法，在一个循环里做多个循环事件

数组链表的题常见

### 移除数组中的元素，返回size

~~~cpp
//暴力
int RemoveElement(vector<int>&nums,int val)
{
    int size = nums.size();
    for(int i = 0; i < nums.size() ;++i)
    {
        if(nums[i] == val)
        {
			for(int j = i;j<nums.size()-1;++j)
            {
				nums[j] = nums[j+1];
            }
            i--;
            size--;
        }
    }
    return size;
}

//双指针
int RemoveElement(vector<int>&nums,int val)
{
	int size = nums.size();
    int SlowPtr = 0;
    for(int FastPtr = 0;FastPtr<nums.size();++FastPtr)
    {
        if(nums[FastPtr]!=val)
        {
			nums[SlowPtr] = nums[FastPtr];
            ++SlowPtr;
        }
    }
    return SlowPtr;
}
~~~

## 滑动窗口也是一种双指针法

常用于找合适大小的字串

### 最小连续子串的和大于等于s

~~~cpp
//暴力美学
int minSubArrayLen(int s,vector<int>&nums)
{
    int res = INT_MAX;
    int sum = 0;
    int Len = 0;
    for(int i = 0;i<nums.size();++i)
    {
        sum = 0;
		for(int j = i;j<nums.size();++j)
        {
			sum += nums[j];
            if(sum >= s) 
            {	
                Len = j-i+1;
        		result = result>Len?Len:result;
                break;
            }
        }//break to here
    }
    return result == MAX_INT? 0:result;
}

//滑动窗口，时刻保证窗口内部满足条件
int minSubArrLen(int s,vector<int>&nums)
{
    int size = MAX_INT;
    int sum = 0;
    int len = 0;
    int l = 0;
    for(int r = 0;r<nums.size();++r)
    {
        sum += nums[r];
        while(sum >= s)
        {
            len = (r-l+1);
            size = size<len?size:len;
            sum -= nums[l];
            ++l;
        }
    }
    return size == INT_MAX? 0:size;
}
~~~



