## 花括号初始化变量

如果使用`{}`初始化且初始值存在丢失信息的风险，则编译器报错

{}用于防范类型转换错误

~~~cpp
int a = 0;
int a = {0};
int a = {};///a=0
int a{};//a=0
int a{0};
int a(0);
long double ld = 3.1415926;
int a{ld};//error,存在丢失信息的危险
int a(ld);//right,d丢失了部分值
~~~

## 右值引用

~~~cpp
double && rref = sqrt(2);
double & ref = sqrt(2);//error
double && jref = 1.0;
double & jre =
~~~



## 空指针

~~~cpp
int* p = nullptr;
int* p = 0;
int* p = NULL;
//上m等价
int*p //此时值无法确定
~~~



## constexpr 变量

将变量声明为constexpr类型以便由编译器来验证变量是否是一个常量表达式

~~~cpp
constexpr int mf=20;  //是常量表达式
constexpr int limit=mf+1;//是常量表达式
constexpr int sz=size();//只有当函数size()是constexpr函数时，才是初始化constexpr变量
~~~

~~~cpp
//constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关
const int *p=nullptr; //p是一个指向整型常量的指针
constexpr int *q=nullptr;//q是一个指向整数的常量指针
~~~

## decltype

返回操作数的类型。

模板类可能自动推导类型，不易判断数据类型

decltype只需推导类型，不需初始化。

~~~cpp
const int ci=0, &cj=ci;
decltype(ci) x=0; //x的类型是const int
decltype(cj) y=x; //y的类型是const int&，y绑定到x
decltype(cj) z;   //错误，z是引用，必须初始化

template (typename T1,typename T2)
void func(T1 a, T2 b) 
{
    decltype(x+y) sum = a+b; 
}

//结合typedef
template (typename T1,typename T2)
void func(T1 a, T2 b) 
{
    typedef decltype(x+y) apb;
    apb arr[2];
    apb sum = a+b; 
}

~~~

**后置返回类型**

~~~cpp
template (typename T1,typename T2)
?type? func(T1 a, T2 b) 
{
    return a+b; 
}
//提前不能知道返回类型，故新增了后置返回类型
template (typename T1,typename T2)
auto func(T1 a, T2 b) ->decltype(a) 
{
    return a+b; 
}
~~~



**decltype 和引用**

- 如果decltype使用的表达式是一个变量，则返回该变量的类型
- 如果decltype使用的表达式不是一个变量，则返回表达式结果对应的类型
- 如果decltype内表达式的内容可作为赋值语句的左值，则decltype得到引用类型。
- 如果decltype内表达式的内容是解引用操作，则decltype得到引用类型。（`解引用指针得到的是所指对象的引用`，而不是值）
- 如果decltype内表达式的内容是变量加上一层或多层括号，编译器把它当成一个表达式。变量是可作为左值的特殊表达式，故此时得到引用类型。

~~~cpp
int i=42, *p=&i, &r=i;
decltype(r) a;    //错，r的推导结果是引用，必须初始化
decltype(r+0) b;  //对，r+0的结果是int，故b是未初始化的int
decltype(*p) c;   //错，解引用得到的结果是引用，c是绑定到int的引用，必须初始化

//decltype内表达式的内容是变量加上一层或多层括号,结果是引用
decltype((i)) d;  //错，d是绑定到int的引用，必须初始化
decltype(i) e;    //对，e是未初始化的int
~~~

## char16_t & char 32_t

~~~cpp
//当 wchar_t 不再能满足字符的数量，c++11新增了这两个无符号字符型，两者得底层都是某种内置的整型
//前缀u表示char16，U表示char32
char16_t ch1 = u'q';
char32_t ch2 = U'q';
~~~

## auto

自动类型推断

~~~cpp
std::vector<int>scores;
//std::vector<int>::iterator it = scores.begin();
auto it = scores.begin();
~~~

## 数组的初始化

~~~cpp
//数组的初始化可以省略等号
int p1[4] {1,2,3,4};
int p2[4] {};//默认为0
int p3[4] = {};//同上

//数组初始化禁止缩窄操作
long p[3] = {1,2,2.4};//error long<float
~~~

## 字符串的初始化

~~~cpp
char ch1[] = {"dklfha"};
char ch2[] {"kdlfja"};
string str1 = {"asfadga"};
string str2 {"dadsf"};
~~~

## 原始字符串

没有转义字符，每个字符搜直接输入

用R来标记

~~~cpp
cout<<R"(Jim,"\n")";//output : Jim,"\n"
//标准形式书写
cout<<"Jim,\"\\n\"";

//当有)出现在字符串，防止提前结束,可在"(之间添加其他的字符，最后的反括号也要匹配
cout<<R"#(..)..)#";
~~~

## 结构体的初始化

~~~cpp
struct test {
	int age;
    string name;
    bool isMarried;
};

test RB {21,"RenBiao",false};
test RR {};//全部为0
//不允许缩窄转换
~~~

## 模板类array

~~~cpp
array<int,5>ai = {1,2,3,4,5};//d
~~~

## 基于范围的for循环

~~~cpp
double price[] = {1.0,2.0,3.0,4.0,5.0};
for(double i : price)
	cout<<i<<endl;

//引用
for(double &i : price）
    i = i*0.8;
    
for(int i : {1,2,3,4})
    cout<<i
~~~

