## 列表初始化变量

如果使用`{}`初始化且初始值存在丢失信息的风险，则编译器报错,换句话说 阻止窄缩变换，禁止将变量传给无法存下它的变量

{}用于防范类型转换错误

~~~cpp
int a = 0;
int a = {0};
int a = {};///a=0
int a{};//a=0
int a{0};
int a(0);
long double ld = 3.1415926;
int a{ld};//error,存在丢失信息的危险
int a(ld);//right,d丢失了部分值
int *ar = new int [4] {2,3,4,5};
//class Bozo
Bozo dribble = {"asd",21};
Bozo fufu{"ad",43};
Bozo *pc = new Bozo{"asd",543};//d

//初始化列表可作为参数
double sum(std::initializer_list<double>il)
{
    ...
}

double s = sum({1,2,3,4});
~~~

## 右值引用

右值可出现在赋值表达式右边，不能对其应用地址运算符的值，字面常量，表达式，返回值函数（不能返回引用）

右值引用可关联到右值，给右值找个地址放

把右值拷贝一份放到地址里，通过这个地址就能找到&&时候的右值的值

~~~cpp
double && rref = sqrt(2);
double && jref = 1.0;
int x = 10,y = 10;
int && z = x+y;//x关联的是 20，以后修改 xy 也不会影响z
~~~

## 转移语义

如果复制之后再删除原来的，就相当于把原来的转移到新的上，这样节约时间

~~~cpp
class Useless
{
private:
    int n;
    char*pc;
public:
    Useless();
    explicit Useless(int k);
    Useless(int k ,char ch);
    Useless(const Uselsee&f);//拷贝构造
    Useless(Useless&&f);//移动语义
    
    Useless& operator=(const Useless&f);//复制赋值
    Useless& operator=(Useless && f);//移动赋值
    ~Useless();
};

Useless::Useless(const Useless&f):n(f.n)
{
	pc = new char[n];
       for(int i = 0;i<n;++i)
        pc[i] = f.pc[i];
}
Useless::Useless(Useless && f):n(f.n)
{
    pc = f.pc;//偷地址
    f.pc = nullptr;
    f.n = 0;
}
Useless& Uselsee::operator=(const Uselsee&f)
{
	if(this == &f)
        return *this;
    delete []pc;
    n = f.n;
    pc = new char[n];
    for(int i = 0;i<n;++i)
        pc[i] = f.pc[i];
    return *this;
}

Useless& Useless::operatpr=(Useless && f)
{
	if(this == &f)
        return *this;
    n = f.n;
    pc = f.pc;
    f.pc = nullptr;
    f.n = 0;
    return *this;
}
~~~

使用左值对对象初始化，将使用复制构造函数，使用右值对对象初始化将使用移动构造函数

## 强制移动

想让右值函数使用左值，

1. 可以static_cast
2. #include<utility> move()

~~~cpp
#include<utility>
class A{
public:
    A&operator=(const A&f);
	A&operator=(A&&f);    
};

A a,b;
b = a;//复制复制
b = move(a);//移动赋值
~~~

## 类的特殊成员函数

默认构造函数，复制构造函数，复制赋值运算符，析构函数，移动构造函数，移动赋值运算符

当不提供的时候，系统默认提供以上全部函数

特殊：当提供了复制构造函数，复制赋值运算符，系统不会默认提供移动构造函数，移动赋值运算符，反之亦然

~~~cpp
//但如果希望使用那些默认的函数，可以用default
class A{
public:
    A(A&&f);
    A() = default;
    A(const A&) = default;
    A&operator=(const A&) = default;
};

//要禁止编译器使用特定的函数，可以用delete
class B{
public:
    A() = default;
    A(const A& ) = delete;
    A&operator=(const A&) = delete;
};
//要想禁止复制，两种方法 将上述函数定义在private，或者加delete，但加delete更好

//default只能用于6个特殊的成员函数，而delete可用于任意函数
~~~

## 委托构造函数

构造函数之间可以相互调用

方法：在初始化列表初始化，先执行初始化列表的构造函数，后构造自己

~~~cpp
class A{
  private:
    int x ;
    double y;
  public:
    A(int);
    A(int ,double);
};

A::A(int m,double n):x(m),y(n){}
A::A(int m):A(m,12.3){}
~~~

## 继承构造函数

派生类继承基类函数using namespace::func

~~~cpp
class A{
public:
    A();
    A(int);
    //非特殊函数也可用
    int func1();
    int func1(int);
    double func1();
}

class A_Son:public A
{
public:
    using A::A;
    using A::func1;
    
    A_Son():A();
};

A_Son o1;//A_Son()
A_Son o2(1);//A(int)
~~~



## 空指针

~~~cpp
int* p = nullptr;
int* p = 0;
int* p = NULL;
//上m等价
int*p //此时值无法确定
~~~



## constexpr 变量

将变量声明为constexpr类型以便由编译器来验证变量是否是一个常量表达式

~~~cpp
constexpr int mf=20;  //是常量表达式
constexpr int limit=mf+1;//是常量表达式
constexpr int sz=size();//只有当函数size()是constexpr函数时，才是初始化constexpr变量
~~~

~~~cpp
//constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关
const int *p=nullptr; //p是一个指向整型常量的指针
constexpr int *q=nullptr;//q是一个指向整数的常量指针
~~~

## decltype

返回操作数的类型。

模板类可能自动推导类型，不易判断数据类型

decltype只需推导类型，不需初始化。

~~~cpp
const int ci=0, &cj=ci;
decltype(ci) x=0; //x的类型是const int
decltype(cj) y=x; //y的类型是const int&，y绑定到x
decltype(cj) z;   //错误，z是引用，必须初始化

template (typename T1,typename T2)
void func(T1 a, T2 b) 
{
    decltype(x+y) sum = a+b; 
}

//结合typedef
template (typename T1,typename T2)
void func(T1 a, T2 b) 
{
    typedef decltype(x+y) apb;
    apb arr[2];
    apb sum = a+b; 
}

~~~

**后置返回类型**

~~~cpp
template (typename T1,typename T2)
?type? func(T1 a, T2 b) 
{
    return a+b; 
}
//提前不能知道返回类型，故新增了后置返回类型
template (typename T1,typename T2)
auto func(T1 a, T2 b) ->decltype(a) 
{
    return a+b; 
}
~~~



**decltype 和引用**

- 如果decltype使用的表达式是一个变量，则返回该变量的类型
- 如果decltype使用的表达式不是一个变量，则返回表达式结果对应的类型
- 如果decltype内表达式的内容可作为赋值语句的左值，则decltype得到引用类型。
- 如果decltype内表达式的内容是解引用操作，则decltype得到引用类型。（`解引用指针得到的是所指对象的引用`，而不是值）
- 如果decltype内表达式的内容是变量加上一层或多层括号，编译器把它当成一个表达式。变量是可作为左值的特殊表达式，故此时得到引用类型。

~~~cpp
int i=42, *p=&i, &r=i;
decltype(r) a;    //错，r的推导结果是引用，必须初始化
decltype(r+0) b;  //对，r+0的结果是int，故b是未初始化的int
decltype(*p) c;   //错，解引用得到的结果是引用，c是绑定到int的引用，必须初始化

//decltype内表达式的内容是变量加上一层或多层括号,结果是引用
decltype((i)) d;  //错，d是绑定到int的引用，必须初始化
decltype(i) e;    //对，e是未初始化的int
~~~

## char16_t & char 32_t

~~~cpp
//当 wchar_t 不再能满足字符的数量，c++11新增了这两个无符号字符型，两者得底层都是某种内置的整型
//前缀u表示char16，U表示char32
char16_t ch1 = u'q';
char32_t ch2 = U'q';
~~~

## long long

~~~cpp
long long y;
unsigned long long x;
~~~



## auto

自动类型推断

~~~cpp
std::vector<int>scores;
//std::vector<int>::iterator it = scores.begin();
auto it = scores.begin();
~~~

## 数组的初始化

~~~cpp
//数组的初始化可以省略等号
int p1[4] {1,2,3,4};
int p2[4] {};//默认为0
int p3[4] = {};//同上

//数组初始化禁止缩窄操作
long p[3] = {1,2,2.4};//error long<float
~~~

## 字符串的初始化

~~~cpp
char ch1[] = {"dklfha"};
char ch2[] {"kdlfja"};
string str1 = {"asfadga"};
string str2 {"dadsf"};
~~~

## 原始字符串

没有转义字符，每个字符搜直接输入

用R来标记

~~~cpp
cout<<R"(Jim,"\n")";//output : Jim,"\n"
//标准形式书写
cout<<"Jim,\"\\n\"";

//当有)出现在字符串，防止提前结束,可在"(之间添加其他的字符，最后的反括号也要匹配
cout<<R"#(..)..)#";
~~~

## 结构体的初始化

~~~cpp
struct test {
	int age;
    string name;
    bool isMarried;
};

test RB {21,"RenBiao",false};
test RR {};//全部为0
//不允许缩窄转换
~~~

## 模板类array

~~~cpp
array<int,5>ai = {1,2,3,4,5};//，不能修改大小，有begin(),end()
~~~

## 基于范围的for循环

~~~cpp
double price[] = {1.0,2.0,3.0,4.0,5.0};
for(double i : price)
	cout<<i<<endl;

//引用
for(double &i : price）
    i = i*0.8;
    
for(int i : {1,2,3,4})
    cout<<i
~~~

## register

声明变量是寄存器存储的自动类型，主要用于函数内外变量名冲突

~~~cpp
int x ;
void func()
{
	register int x;
    //int x ;//也ok，在函数内部会隐藏外部的
}
~~~

## 名称空间

名称空间可以是全局的，也可以放在其他的名称空间里

~~~cpp
namespace Jack{
    int x;
}

int x;

int main()
{
    int x;
    
    cout<<::x
    cout<<Jack::x;
    cout<<x;
}
~~~

~~~cpp
namespace NS_1{
    //命名空间可以using其他命名空间
    using namespace std;
    //嵌套
    namespace NS_2{
        int x;
    }
    int x;
}

int main()
{
	using NS_1::NS_2::x;
    
    using namespace NS_1;//此时NS_2也被包含
}

~~~

~~~cpp
//namespace别名
namespace This_Is_A_Long_Name_1{
    namespace This_Is_A_Long_Name_2{
        int x;
    }
}
namespace Short = This_Is_A_Long_Name_1::This_Is_A_Long_Name_2;
using short::x;
~~~

~~~cpp
static int x;
//未命名的命名空间和内部链接等价
namespace{
    int x;
}
~~~

## 枚举类

~~~cpp
//传统枚举
enum egg{small,large};
enum Tshirt{small,XLarge};
//由于两个枚举在一个命名空间下，两个枚举的small会冲突
//不可完全移植

//枚举类
enum class egg{small,large};
enum class Tshirt{small,XLarge};
//和上等价 enum struct TShirt{small,XLarge};

egg e1 = egg::small;
Tshirt t1 = TShirt::small;

//常规枚举底层类型随实现而异
//自定义底层类型
enum class:double egg{small,large};
~~~

##  类内初始化

~~~c'p'p
//初始化列表初始化
class Queue
{
private:
    //被声明为非静态常量，引用的类成员，必须用初始化列表初始化
    Queue& sd;
    const int x;

public:
    Queue(int qs,queue&d):x(qs),sd(d){}
};

//类内初始化,和初始化列表初始化等价
class Queue
{
	const int x = 1;
	int y {0};
	//可用 = {} 初始化，但不能用()初始化
}

//如果类内初始化和初始化列表同时存在，初始化列表会覆盖类内初始化
~~~

## 模板别名

typedef为模板具体化指定别名

~~~cpp
typedef array<int,12> arrd;
~~~

这样很麻烦，且不能用于模板，于是c++11提出了 **模板别名**

~~~cpp
template<typename T>
using arrtype = array<T,12>;

arrtype<double>gal; //array<double,12>gal;
~~~

而将using用于非模板，和常见的typedef等价

~~~cpp
using cStar = const char*;
//typedef const char* cStar;
~~~

## noexcept

指出函数不会引发异常

~~~cpp
double marn()noexcept;//y
~~~

## 构造函数

~~~cpp
string(string&&str)//移动构造函数，类似于复制构造函数，不保证把str视为const，优化性能
    
string(initializer_list<char>il)//列表初始化
string piano = {'p','i','a','n','o'};
~~~

## 基于范围的for循环

~~~cpp
//for
for(it = scroes.begin();it!=scores.end();++it)
    Show(*it);
//for_each
for_each(scores.begin(),scores.end(),Show);
//基于范围的for循环
for(auto x : scores)
    Show(x);
for(auto& x : scores)
    Show(x);
~~~

## forward_list单链表

不可反转容器

## 无序关联容器

关联容器是基于树结构的，非关联容器是基于哈希表结构的

## 返回类型后置

用于处理在运行时参数确定了才能确定返回类型的情况

~~~cpp
double f1(double,int);
auto eff(T t,U u)->decltype(T*U)
{
	...
}
~~~

## nullptr

nullptr == 0 

但不能把nullptr传给int型

## 智能指针

unique_ptr

shared_ptr

weak_ptr

## explicit

阻止自动转换，显式转换

~~~cpp
class A
{
    A(int);
    explicit A(double);
    operator int()const;
    explicit double()const;
};

A a , b;
a = 5;
//a = 0.5;//error
a = A(0.5);
int m = a;
double n = double(b);
~~~

## STL新方法

用法和没有c的一样，只是将元素视为const

cbegin(),cend(),crbegin(),crend()

## valarray

valarray 模板为数值数据处理提供的功能比任何序列容器（例如 vector）都多

## 管理虚函数

override :表明要覆盖一个基类的虚函数，如果类型不匹配就会报错

final：禁止派生类覆盖方法

## lambda表达式

效率高，函数指针阻止内联，lambda、函数符不阻止内联

lambda可访问作用域内的动态变量

~~~Cpp
auto lam = [](int x)->bool{return x%3==0};
count = count_if(n.begin(),n.end(),lam);
bool res = lam(3);
~~~

~~~cpp
[z]//按值访问z
[&z]//按引用访问z
[=]//按值访问所有变量
[&]//按引用访问所有变量
[z,&q]//按值z，引用q
[=,&q]//按引用q，其他按值
~~~

## 包装器（适配器）

function对创建多个相同实例的情况有帮助

下面等价

~~~cpp
#include <functional>
template<typename T,typename F>
T use_f(T v, F f)
{
    static int count = 0;
    count++;
    return f(v);       
}
double func1(double x){return 2*x;}
double func2(double x){return x*x;}
int main()
{
	double y =1.21;
    function<double(double)>ef1 = func1;
    function<double(double)>ef2 = func2;
    function<double(double)>ef3 = [](double u){return u*u};
    use_f(y,ef1);
    use_f(y,ef2);
    use_f(y,ef3);
    //function包装后，实例了一次调用了六次
}
/////////////////////////
typedef function<double(double)> fdd;
use_f(y,fdd(func1));
use_f(y,fdd(func2));
use_f(y,fdd(func3));

////////////////////////
template<typename T>
T use_f( T v,function<T(T)>f){
    static int count = 0;
    count++;
    return f(v);
}
use_f<double>(y,func1);
use_f<double>(y,func2);
use_f<double>(y,[](double u){return u*u});
~~~

## 可变参数模板

...是元运算符

Args是模板参数包

args是函数参数包，可为任意类型

~~~cpp
template<typename T,typename ...Args>
void show_list(const T& val,const Args& ...args)
{
    cout<<val<<'，';
	show_list(args...);//展开参数包，在这里调用会递归，直到args被调用完
}

template<typename T>
void show_list(const T& val)
{
    cout<<val;//最后一个元素调用这个版本，就不会多一个，
}

show_list(12,2.4,'d',"how");
~~~



## 并行编程

thread_local将变量声明为静态存储，生命和线程一致

## 新增的库

random增加复杂的随机数工具，随机分布，正态分布，二次分布等

chrono处理时间间隔

tuple广义的pair  可以存储多个类型不同的值

ratio编译阶段有理数算术库能准确表达任何有理数

regex支持正则表达式库

