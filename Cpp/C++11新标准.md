## 花括号初始化变量

如果使用`{}`初始化且初始值存在丢失信息的风险，则编译器报错

~~~cpp
int a = 0;
int a = {0};
int a{0};
int a(0);
long double ld = 3.1415926;
int a{ld};//error,存在丢失信息的危险
int a(ld);//right,d丢失了部分值
~~~

## 右值引用

## 空指针

~~~cpp
int* p = nullptr;
int* p = 0;
int* p = NULL;
//上m等价
int*p //此时值无法确定
~~~



## constexpr 变量

将变量声明为constexpr类型以便由编译器来验证变量是否是一个常量表达式

~~~cpp
constexpr int mf=20;  //是常量表达式
constexpr int limit=mf+1;//是常量表达式
constexpr int sz=size();//只有当函数size()是constexpr函数时，才是初始化constexpr变量
~~~

~~~cpp
//constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关
const int *p=nullptr; //p是一个指向整型常量的指针
constexpr int *q=nullptr;//q是一个指向整数的常量指针
~~~

## decltype

返回操作数的类型。

decltype只需推导类型，不需初始化。

~~~cpp
const int ci=0, &cj=ci;
decltype(ci) x=0; //x的类型是const int
decltype(cj) y=x; //y的类型是const int&，y绑定到x
decltype(cj) z;   //错误，z是引用，必须初始化
~~~

**decltype 和引用**

- 如果decltype使用的表达式是一个变量，则返回该变量的类型
- 如果decltype使用的表达式不是一个变量，则返回表达式结果对应的类型
- 如果decltype内表达式的内容可作为赋值语句的左值，则decltype得到引用类型。
- 如果decltype内表达式的内容是解引用操作，则decltype得到引用类型。（`解引用指针得到的是所指对象的引用`，而不是值）
- 如果decltype内表达式的内容是变量加上一层或多层括号，编译器把它当成一个表达式。变量是可作为左值的特殊表达式，故此时得到引用类型。

~~~cpp
int i=42, *p=&i, &r=i;
decltype(r) a;    //错，r的推导结果是引用，必须初始化
decltype(r+0) b;  //对，r+0的结果是int，故b是未初始化的int
decltype(*p) c;   //错，解引用得到的结果是引用，c是绑定到int的引用，必须初始化

//decltype内表达式的内容是变量加上一层或多层括号,结果是引用
decltype((i)) d;  //错，d是绑定到int的引用，必须初始化
decltype(i) e;    //对，e是未初始化的int
~~~

